1、自我介绍，包括基本信息，所做的项目和擅长东西。

2、根据你介绍的项目情况来问一些问题，包括技术，业务，架构。
主要是要对项目足够了解，包括封装的技框架，数据走向，以及遇到问题怎么解决的。

3、频率比较高的技术问题：

1、分布式的项目用过么？结合项目讲一下。
2、多线程，设计模式，redis缓存，MQ生产者和消费者，消息发送失败的情况怎么处理？
3、性能优化有做到过吗？举个例子。

=============================================================================================
什么是 Spring Cloud？
　　Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。

Spring cloud的优点。
Springboot和spring cloud的区别。


(spring cloud 断路器的作用是什么？
在分布式环境下，特别是微服务结构的分布式系统中， 一个软件系统调用另外一个远程系统是非常普遍的。这种远程调用的被调用方可能是另外一个进程，或者是跨网路的另外一台主机, 这种远程的调用和进程的内部调用最大的区别是，远程调用可能会失败，或者挂起而没有任何回应，直到超时。更坏的情况是， 如果有多个调用者对同一个挂起的服务进行调用，那么就很有可能的是一个服务的超时等待迅速蔓延到整个分布式系统，引起连锁反应， 从而消耗掉整个分布式系统大量资源。最终可能导致系统瘫痪。
断路器（Circuit Breaker）模式就是为了防止在分布式系统中出现这种瀑布似的连锁反应导致的灾难。
Hystrix 具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能,
)

Hystrix 的三种状态，工作原理
https://blog.csdn.net/qq_41347385/article/details/106044175?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control


ribbon和feign区别  （负载均衡）
https://www.cnblogs.com/xiaofeng-fu/p/12119125.html

https://www.cnblogs.com/zhangkaimin/p/12068076.html

spring cloud的 Netflix ribbon 和 feign 的区别：

      Ribbon：Ribbon 是一个基于 HTTP 和 TCP 客户端的负载均衡器它可以在客户端配置 ribbonServerList（服务端列表），然后轮询请求以实现均衡负载它在联合 Eureka 使用时ribbonServerList 会被 DiscoveryEnabledNIWSServerList 重写，扩展成从 Eureka 注册中心获取服务端列表同时它也会用 NIWSDiscoveryPing 来取代 IPing，它将职责委托给 Eureka 来确定服务端是否已经启动。 使用 HttpClient 或 RestTemplate 模拟http请求，步骤相当繁琐。

     用法： 

 RestTemplate注入到容器中，@LoadBalanced注解使用默认负载均衡算法（可以使用自定义）


     Feign:	

Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。采用接口的方式， 只需要创建一个接口，面向接口；然后在上面添加注解即可 ，将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写 客户端变得非常容易。类似于 mybatis 的 @Mapper注解 。

      用法：

      在 api 工程 定义一个接口API，
     a) 添加@FeignClient 注解，指定微服务名称 MICROSERVICECLOUD-DEPT
     b) 指定请求地址 @RequestMapping

--------------------------------------------------------------------------------------------------------------
说说spring
AOP （接口类型，继承）代理对象 动态代理（继承，handle，proc，反射拿到目标接口）
spring 作用域，单例生成时安全的吗，bean标签，多例
中间件  底层原理

https://zhuanlan.zhihu.com/p/106729320


spring 自动装配bean 有几种方式？
https://blog.csdn.net/meism5/article/details/90446694

spring 配置文件中 <bean> 节点的 autowire 参数可以控制 bean 自动装配的方式

default - 默认的方式和 "no" 方式一样
no - 不自动装配，需要使用 <ref />节点或参数
byName - 根据名称进行装配
byType - 根据类型进行装配
constructor - 根据构造函数进行装配
--------------------------------------------------------------------------------------------------------------
脑裂是什么，zookeeper是怎么解决的
什么是脑裂
脑裂(split-brain)就是“大脑分裂”，也就是本来一个“大脑”被拆分了两个或多个“大脑”，我们都知道，如果一个人有多个大脑，并且相互独立的话，那么会导致人体“手舞足蹈”，“不听使唤”。

脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。

本篇文章着重来给大家讲一下Zookeeper中的脑裂问题，以及是如果解决脑裂问题的。

Zookeeper集群中的脑裂场景
对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房：

而如果过半机制的条件是set.size() >= 3，那么机房1和机房2都会选出一个Leader，这样就出现了脑裂。所以我们就知道了，为什么过半机制中是大于，而不是大于等于。就是为了防止脑裂。

https://www.cnblogs.com/baolingye/p/11667717.html

-----------------------------------------------------------------------------------------------------------

微服务接口之间调用

https://www.cnblogs.com/code-craftsman/p/11556672.html

微服务之间的调用有两种方式，RPC和事件驱动。事件驱动是更好的方式，因为它是松耦合的。但如果业务逻辑是紧耦合的，RPC方式也是可行的（它的好处是代码更简单），而且你还可以通过选取合适的协议（Protobuf+gRPC）来降低这种紧耦合带来的危害。由于事件溯源和事件通知的相似性，很多人把两者弄混了，但它们实际上是完全不同的东西。微服务的数量不宜太多，可以先创建比较大的微服务（更像是服务组合）。如果你还是不能确定是否采用微服务架构，可以先从“内部微服务设计”开始，再逐渐拆分。

-----------------------------------------------------------------------------------------------------------
Redisredis击穿，穿透，雪崩以及解决方案。
缓存雪崩
数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。

比如一个雪崩的简单过程：

1、redis集群大面积故障

2、缓存失效，但依然大量请求访问缓存服务redis

3、redis大量失效后，大量请求转向到mysql数据库

4、mysql的调用量暴增，很快就扛不住了，甚至直接宕机

5、由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。


预防

1.缓存的高可用性

缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。

2.缓存降级

可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。

当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级，这里会涉及到运维的配合。

降级的最终目的是保证核心服务可用，即使是有损的。

比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。

在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如：

（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；

（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；

（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；

（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

3.Redis备份和快速预热

1)Redis数据备份和恢复

2)快速缓存预热

4.提前演练

最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。


缓存穿透
缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决思路：

如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。

可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key

（为什么用redis？    如何防止雪崩？
redis模式？是单线程吗？多线程？   哨兵、主从，
redis 主从模式,哨兵模式,cluster(集群)模式 
redis分布式锁？）

------------------------------------------------------------------------------------------
mq
https://www.cnblogs.com/shamo89/p/8092989.html
ActiveMQ的消息持久化机制

https://www.cnblogs.com/bigberg/p/8195622.html
RabbitMQ消息持久化

=====================================================================
java  基础

java8 新特性

https://www.runoob.com/java/java8-new-features.html

1	Lambda 表达式
2	方法引用
3	函数式接口
4	默认方法
5	Stream
6	Optional 类
7	Nashorn, JavaScript 引擎
8	新的日期时间 API
9	Base64

Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。

方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。

默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。

新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。

Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。

Date Time API − 加强对日期与时间的处理。

Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。

Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。


------------------------------------------------
listiterator和iterator的区别

区别：1、Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。2、Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。3、ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

Iterator和ListIterator区别
我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：

（1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能
（2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。
（3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。
（4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。
------------------------------------------------




java  基础类型，byte,short,int,double,float,long,char,boolean
数据结构  array list  map  set  list 扩容

JAVA数据结构有以下几种：

1、List：

List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下 >标）来访问List中的元素，这类似于Java的数组。

2、Vector：

基于数组（Array）的List，其实就是封装了数组所不具备的一些功能方便我们使用，所以它难易避免数组的限制，同时性能也不可能超越数组。

另外很重要的一点就是Vector是线程同步的(sychronized)的，这也是Vector和ArrayList 的一个的重要区别。 

3、ArrayList：

同Vector一样是一个基于数组上的链表，但是不同的是ArrayList不是同步的。所以在性能上要比Vector好一些，但是当运行到多线程环境中时，可需要自己在管理线程的同步问题。

4、LinkedList：

LinkedList不同于前面两种List，它不是基于数组的，所以不受数组性能的限制。 它每一个节点（Node）都包含两方面的内容：节点本身的数据（data），下一个节点的信息（nextNode）。 

所以当对LinkedList做添加，删除动作的时候就不用像基于数组的ArrayList一样，必须进行大量的数据移动。只要更改nextNode的相关信息就可以实现了，这是LinkedList的优势。

5、HashSet：

虽然Set同List都实现了Collection接口，但是他们的实现方式却大不一样。List基本上都是以Array为基础。

但是Set则是在 HashMap的基础上来实现的，这就是Set和List的根本区别。HashSet的存储方式是把HashMap中的Key作为Set的对应存储项。

6、HashMap：

基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。(除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。)此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

7、HashTable：

Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。

Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为nul

------------------------------------------------------------------------------------------------------------------
ArrayList和LinkedList区别
1. 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；

2. 底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）

3. 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。

4. 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。

5. 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）

arraylist 和 linklist 谁占内存多？linklist 多

-------------------------------------------------------------------------------------------------------------------
一、HashMap底层数据结构
JDK1.7及之前：数组+链表
JDK1.8：数组+链表+红黑树


关于HashMap基本的大家都知道，但是为什么数组的长度必须是2的指数次幂，为什么HashMap的加载因子要设置为0.75，为什么链表长度大于等于8时转成了红黑树？

HashMap添加元素分析
当添加元素时，会通过哈希值和数组长度计算计算下标来准确定位该元素应该put的位置，通常我们为了使元素时分布均匀会使用取模运算，用一个值去模上总长度，例如：index=hashCode % arr.length（实际并非这样，后面讲解）,计算出index后，就会将该元素添加进去，理想状态下是将每个值都均匀的添加到数组中，但问题是不可能达到这样的理想状态，这时候就会产生哈希冲突，例如：小龙女通过计算添加到了数组3号位置，但是此时杨过这个元素通过计算产生了一个与小龙女相同的索引位置，这是就产生了哈希冲突

此时，就产生了第二种数据结构——链表，冲突的元素会在该索引处以链表的形式保存

但是当链表的长度过长时，其固有弊端就显现出来了，即查询效率较低，时间复杂度可能会达到O(n)级别，而数组的查询时间复杂度仅为O(1)

此时，就引出了第三种数据结构——红黑树，红黑树是一棵接近于平衡的二叉树，其查询时间复杂度为O(logn)，远远比链表的查询效率高。但如果链表长度不到一定的阈值，直接使用红黑树代替链表也是不行的，因为红黑树的自身维护的代价也是比较高的，每插入一个元素都可能打破红黑树的平衡性，这就需要每时每刻对红黑树再平衡（左旋、右旋、重新着色）

二、为什么数组的长度必须是2的指数次幂
HashMap中数组的初始长度为16，我们创建一个空参的HashMap并点进源码如下图，从开发者提供的注释可以看到，空参的HashMap初始容量是16，，默认加载因子为0.75

阿里的人突然问我为啥扩容因子是0.75，回来总结了一下； 提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，

HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。

通常，加载因子需要在时间和空间成本上寻求一种折衷。

加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；

加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。

在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。

选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择， 


①HashMap的工作原理

HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。

当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。
我们都知道HashMap是数组+链表组成的，bucket数组是HashMap的主体，而链表是为了解决哈希冲突而存在的，但是很多人不知道其实HashMap是包含树结构的，但是得有一点 注意事项，什么时候会出现红黑树这种红树结构的呢？我们就得看源码了，源码解释说默认链表长度大于8的时候会转换为树。我们看看源码说的

-------------------------------------------------------------------------------------------------------------------
String、StringBuffer与StringBuilder之间区别

  	   	
String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间
StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量，多线程操作字符串	
StringBuilder 可变类，速度更快，线程不安全，单线程操作字符串

-------------------------------------------------------------------------------------------------------------------
java-多线程

Clallable 和 Runnable的区别 ，哪个有返回值？
不同之处：
1.Callable可以返回一个类型V，而Runnable不可以
2.Callable能够抛出checked exception,而Runnable不可以。
3.Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的
4.Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.


1、sleep() 和 wait() 有什么区别？

类的不同：sleep() 来自 Thread，wait() 来自 Object。
释放锁：sleep() 不释放锁；wait() 释放锁。
用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。

2、notify()和 notifyAll()有什么区别？

notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。

3.线程的 run()和 start()有什么区别？

start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。


（多线程（几种状态？阻塞状态怎么产生？wait （notify方法唤醒）， sleep（不需要唤醒）） ： wait 和 sleep 区别
 i++ 是线程安全？ 不安全  （原子类是安全的）
线程池   为什么用线程池 好处，怎么创建线程池,几种方式，两种 哪种好
java中创建线程池的方式一般有两种：
通过Executors工厂方法创建
通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)自定义创建）
----------------------------------------------------------------------------------------------------------------------------
final finally 和 finalize的区别
https://www.cnblogs.com/ktao/p/8586966.html

--------------------------------------------------------------------------------------------------------------------------
重载(Overload) 和 重写(Override) 区别

java多态，接口继承，参数类型不确定时，扩展性（面向对象编程有三大特性：封装、继承、多态）
多态就是同一个接口,使用不同的实例而执行不同操作, 多态性是对象多种表现形式的体现
重载和重写， 重载（方法传参不同），重写 子类扩展父类， 返回值相同
      所以对于多态我们可以总结如下：

      指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

重载规则:

被重载的方法必须改变参数列表(参数个数或类型不一样)；
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。
无法以返回值类型作为重载函数的区分标准。

重写(Override)
重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重写方法的规则：
1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。
2、返回的类型必须一直与被重写的方法的返回类型相同或其子类，否则不能称其为重写而是重载。
3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）
4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：
父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。


构造器能重写吗？

　　重写是子类方法重写父类的方法；

　　重写的方法，方法名不变；

　　类的构造方法名必须与类名一致；

　　父类的构造方法如果能够被子类重写，那么子类类名必须与父类类名一致；

　　综上，构造方法重写是伪命题！

首先，构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以根本谈不上继承。 

又由于构造器不能继承，所以就不能被重写。但是，在同一个类中，构造器是可以被重载的。

----------------------------------------------------------------------------------------------------------------------------
Error：和 Exception：区别

Error：Error类对象由 Java
虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误（Virtual
MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现
OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之
外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通常是使用Error的子类描述。
Exception：在Exception分支中有一个重要的子类RuntimeException（运行时异常），该类型的异常自动为你所编写的程序定义ArrayIndexOutOfBoundsException（数组下标越界）、NullPointerException（空指针异常）、ArithmeticException（算术异常）、MissingResourceException（丢失资源）、ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而RuntimeException之外的异常我们统称为非运行时异常，类型上属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

----------------------------------------------------------------------------------------------------------------------------
1、try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的 code 会不会被执行，什么时候被执行，在 return 前还是后?
答案：会执行，在方法返回调用者前执行。
2、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？


----------------------------------------------------------------------------------------------------------------------------
垃圾回收机制和算法。

https://zhuanlan.zhihu.com/p/73628158

java垃圾回收
https://www.cnblogs.com/gtea/p/13907193.html
https://zhuanlan.zhihu.com/p/54851319

----------------------------------------------------------------------------------------------------------------------------









=============================================

















https://blog.csdn.net/iblade/article/details/78196016

要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：

检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。
从图中可以看出所有异常类型都是内置类Throwable的子类，因而Throwable在异常类的层次结构的顶层。
接下来Throwable分成了两个不同的分支，一个分支是Error，它表示不希望被程序捕获或者是程序无法处理的错误。另一个分支是Exception，它表示用户程序可能捕捉的异常情况或者说是程序可以处理的异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常。

Java异常又可以分为不受检查异常（Unchecked Exception）和检查异常（Checked Exception）。

下面将详细讲述这些异常之间的区别与联系：





答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。

3、运行时异常与受检异常有何异同？

答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：
- 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
- 优先使用标准的异常
- 每个方法抛出的异常都要有文档
- 保持异常的原子性
- 不要在catch中忽略掉捕获到的异常









-----------Dubbo-----------

2、Dubbo 的整体架构设计有哪些分层?

接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现

配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心

服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory

服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService

路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce

监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService

远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter

信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer

网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec

数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool





-----------java-JVM----------
Java虚拟机内存的五大区域
Java的运行离不开Java虚拟机的支持，分别是堆，方法区，虚拟机栈，本地方法栈，程序计数器

堆。 堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，值得一提的是从JDK1.7版本之后，运行时常量池从方法区移到了堆上。
方法区。它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。
虚拟机栈。虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
本地方法栈。与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
程序计数器。指示Java虚拟机下一条需要执行的字节码指令。


Mybatis与Hibeinate的区别？Mybatis 半自动化，Hibeinate 全自动化。Mybatis 实现一对多查询
MyBatis因为具有封装少，映射多样化，支持存储过程，可以进行SQL优化等特点。使得它取代了Hibernate成为了java互联网中首选的持久框架。
无论MyBatis或Hibernate都可以称为ORM框架，Hibernate的设计理念是完全面向POJO的，而MyBatis不是。
Hibernate基本不再需要编写SQL就可以通过映射关系来操作数据库，是一种全表映射的体现，而MyBatis需要我们提供SQL去运行。程序员不用精通SQL，只要懂得操作POJO就能够操作对应数据库的表。


springboot  启动类 里 用的注解

sql优化

Eureka 和 ZooKeeper的区别
https://blog.csdn.net/java_xth/article/details/82621776

Eureka和Zookeeper就是CAP定理中的实现，Eureka（保证AP），Zookeeper（保证CP）。
在分布式领域有一个很著名的CAP定理：C：数据一致性。A：服务可用性。P：分区容错性（服务对网络分区故障的容错性）。

RDBMS==>（MySql,Oracle,SqlServer等关系型数据库）遵循的原则是：ACID原则（A：原子性。C：一致性。I：独立性。D：持久性。）。

NoSql==>    （redis,Mogodb等非关系型数据库）遵循的原则是：CAP原则（C：强一致性。A:可用性。P：分区容错性）。

CAP理论也就是说在分布式存储系统中，最多只能实现以上两点。而由于当前网络延迟故障会导致丢包等问题，所以我们分区容错性是必须实现的。也就是NoSqL数据库P肯定要有，我们只能在一致性和可用性中进行选择，没有Nosql数据库能同时保证三点。（==>AP 或者 CP）

提出一个想法，当你面对双十一这种业务处理时，你是选择AP还是CP呢？

个人想法是在面对这种业务处理时，先保证可用性也就是AP原则（服务器不能瘫痪），在过了双十一高峰，再核对数据，保证数据一致性。


jvm调优


1、开发框架
springboot  启动类 里 用的注解
redis,分布式锁。
熔断器是用来做什么的
dubbo和clould的区别。

2、注册中心
Eureka 和 ZooKeeper的区别

3、持久化层
Mybatis与Hibeinate的区别？
sql优化
分库分表

4、线程方面
Clallable 和 Runnable的区别 ，不同之处，哪个有返回值？

5、数据结构
arraylist 和 linklist 谁占内存多？linklist 多

6、通讯mq
MQ的用处。mq的信息处理方法

7、java基础
多线程高并发。
jvm调优

8、linux指令

9、版本管理
maven package和maven instore


springboot 有 哪些注解？
https://www.sohu.com/a/324791519_99952211

注解(annotations)列表

@SpringBootApplication：

包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。

@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。

@EnableAutoConfiguration 自动配置。

@ComponentScan 组件扫描，可自动发现和装配一些Bean。

@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。

@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。

@Autowired自动导入。

@PathVariable获取参数。

@JsonBackReference解决嵌套外链问题。

@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。




扫描路径
自动注解，config引入另外一个config


redis 失效时间

runtime 异常会 回滚吗

事务，写注解

事务全部回滚

mq封装好 怎么调用

底层rabbit mq，  rabbit mq消费失败怎么办，消费者 消费失败后怎么办，反一个状态，  第二个来 能消费吗？

springboot 把 tomcat 外置？

泛型

可变类型

继承 和 实现 区别

jdk8，接口里面可以写实现吗？

over  重写 重载

list  如何线程安全 ，用锁，ancopy

list 如何删除一个元素？元素可以重复，无序的，  如何排序？

mysql 批量删除，循环遍历

mybaits 1个参数不识别

springclound  组件
下面只简单介绍下经常用的5个

服务发现——Netflix Eureka
客服端负载均衡——Netflix Ribbon
断路器——Netflix Hystrix
服务网关——Netflix Zuul
分布式配置——Spring Cloud Config


熔断超时怎么设置？

网关做流量统计？










String为什么不可变？
线程安全和不安全
spring aop ioc 有几种设计模式？
dubbo 负载均衡策略
RPC框架


springboot  启动类 里 用的注解

sql优化


Array list 和linked list的区别。
Array list内存空间连续吗？linked list？
创建一个ArrayList对象，该对象存放在堆内存中，并且是一个内存连续的内存区域。du
1、ArrayList是用数组实现的，这个数组的内存是连续的，不存在相邻元素之间还隔着其他内存。
2、索引ArrayList时，速度比原生数组慢是因为你要用get方法，这是一个函数调用，而数组直接用[ ]访问，相当于直接操作内存地址，速度当然比函数调用快。
3、新建ArrayList的时候，JVM为其分配一个默认或指定大小的连续内存区域（封装为数组）。
4、每次增加元素会检查容量，不足则创建新的连续内存区域（大小等于初始大小+步长），也用数组形式封装，并将原来的内存区域数据复制到新的内存区域，然后再用ArrayList中引用原来封装的数组对象的引用变量引用到新的数组对象：

list和set 区别？
List方法与set方法的区别

（1）重复对象

list方法可以允许重复的对象，而set方法不允许重复对象

（2）null元素

list可以插入多个null元素，而set只允许插入一个null元素

（3）容器是否有序

list是一个有序的容器，保持了每个元素的插入顺序。即输出顺序就是输入顺序，而set方法是无序容器，无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序



迭代器  集合arraylist
使用for循环还是迭代器Iterator对比
采用ArrayList对随机访问比较快，而for循环中的get()方法，采用的即是随机访问的方法，因此在ArrayList里，for循环较快
采用LinkedList则是顺序访问比较快，iterator中的next()方法，采用的即是顺序访问的方法，因此在LinkedList里，使用iterator较快
从数据结构角度分析,for循环适合访问顺序结构,可以根据下标快速获取指定元素.而Iterator 适合访问链式结构,因为迭代器是通过next()和Pre()来定位的.可以访问没有顺序的集合.
而使用 Iterator 的好处在于可以使用相同方式去遍历集合中元素，而不用考虑集合类的内部实现（只要它实现了 java.lang.Iterable 接口），如果使用 Iterator 来遍历集合中元素，一旦不再使用 List 转而使用 Set 来组织数据，那遍历元素的代码不用做任何修改，如果使用 for 来遍历，那所有遍历此集合的算法都得做相应调整,因为List有序,Set无序,结构不同,他们的访问算法也不一样.（还是说明了一点遍历和集合本身分离了）











https://www.cnblogs.com/zdz8207/p/redis-qps-cluster.html





















































